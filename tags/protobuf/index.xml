<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>protobuf on Coder2z's Blog</title><link>/tags/protobuf/</link><description>Recent content in protobuf on Coder2z's Blog</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Sun, 12 Jul 2020 15:52:44 +0800</lastBuildDate><atom:link href="/tags/protobuf/index.xml" rel="self" type="application/rss+xml"/><item><title>Protobuf通信协议</title><link>/post/golang/protobuf%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/</link><pubDate>Sun, 12 Jul 2020 15:52:44 +0800</pubDate><guid>/post/golang/protobuf%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/</guid><description>RPC的调用过程 一个正常的RPC过程可以分为一下几个步骤：
client调用client stub，这是一次本地过程调用。 client stub将参数打包成一个消息，然后发送这个消息。打包过程也叫做marshalling。 client所在的系统将消息发送给server。 server的的系统将收到的包传给server stub。 server stub解包得到参数。 解包也被称作 unmarshalling。 server stub调用服务过程。返回结果按照相反的步骤传给client。 在上述的步骤实现远程接口调用时，所需要执行的函数是存在于远程机器中，即函数是在另外一个进程中执行的。因此，就带来了几个新问题：</description></item><item><title>Golang微服务开发-grpc</title><link>/post/golang/golang%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91-grpc/</link><pubDate>Fri, 10 Jul 2020 08:12:21 +0800</pubDate><guid>/post/golang/golang%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91-grpc/</guid><description>什么是grpc grpc官网：https://www.grpc.io/
A high-performance, open-source universal RPC framework
这个是官方对他的解释。这里就出现了一个新的名称RPC。什么是RPC呢?</description></item><item><title>Protoc-go修改生成的文件的结构体的tag</title><link>/post/golang/protoc-go%E4%BF%AE%E6%94%B9%E7%94%9F%E6%88%90%E7%9A%84%E6%96%87%E4%BB%B6%E7%9A%84%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84tag/</link><pubDate>Tue, 07 Jul 2020 09:22:38 +0800</pubDate><guid>/post/golang/protoc-go%E4%BF%AE%E6%94%B9%E7%94%9F%E6%88%90%E7%9A%84%E6%96%87%E4%BB%B6%E7%9A%84%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84tag/</guid><description>使用场景 在使用protoc生成的文件中生成的结构体的json没有小写，有时候我们就需要使用小写，最主要的就是在使用gin的时候还需要使用bind来绑定上传的东西。但是生成的*.pd.go又不建议我们去改。这时候就需要使用protoc-go-inject-tag，这里还有个更重要的地方，这里简单描述下：生成的结构体中的tag里面有个omitempty，这个的作用呢，就是在数据传输过程中，自动去掉false 0 &amp;quot;&amp;quot;这些数据。这里简单的举个例子，比如你的grpc服务端返回给客户端一个值为false的bool类型数据。但是在客户端接受的时候，这个字段就直接没有了。所以这样肯定是不行的。所以这里需要集体的去掉tag中的omitempty。这个时候protoc-go-inject-tag就可以满足这个需求。在之后的微服务（go-micro）开发中，这个也是很重要的地方！
git地址：https://github.com/favadi/protoc-go-inject-tag
安装 go get github.com/favadi/protoc-go-inject-tag 使用 只需要在.</description></item></channel></rss>