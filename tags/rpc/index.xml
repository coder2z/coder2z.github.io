<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>rpc on Coder2z's Blog</title><link>/tags/rpc/</link><description>Recent content in rpc on Coder2z's Blog</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Sun, 12 Jul 2020 15:52:44 +0800</lastBuildDate><atom:link href="/tags/rpc/index.xml" rel="self" type="application/rss+xml"/><item><title>Protobuf通信协议</title><link>/post/golang/protobuf%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/</link><pubDate>Sun, 12 Jul 2020 15:52:44 +0800</pubDate><guid>/post/golang/protobuf%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/</guid><description>RPC的调用过程 一个正常的RPC过程可以分为一下几个步骤：
client调用client stub，这是一次本地过程调用。 client stub将参数打包成一个消息，然后发送这个消息。打包过程也叫做marshalling。 client所在的系统将消息发送给server。 server的的系统将收到的包传给server stub。 server stub解包得到参数。 解包也被称作 unmarshalling。 server stub调用服务过程。返回结果按照相反的步骤传给client。 在上述的步骤实现远程接口调用时，所需要执行的函数是存在于远程机器中，即函数是在另外一个进程中执行的。因此，就带来了几个新问题：</description></item></channel></rss>