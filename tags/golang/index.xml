<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>golang on Coder2z Blog</title><link>/tags/golang/</link><description>Recent content in golang on Coder2z Blog</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Tue, 15 Sep 2020 09:35:21 +0800</lastBuildDate><atom:link href="/tags/golang/index.xml" rel="self" type="application/rss+xml"/><item><title>Golang踩坑笔记</title><link>/post/golang/golang%E8%B8%A9%E5%9D%91%E7%AC%94%E8%AE%B0/</link><pubDate>Tue, 15 Sep 2020 09:35:21 +0800</pubDate><guid>/post/golang/golang%E8%B8%A9%E5%9D%91%E7%AC%94%E8%AE%B0/</guid><description>golang中的一些陷阱 int和float64类型不匹配 Go类型系统不允许在整数和浮点变量之间进行任何数学运算。
比如
package main import &amp;quot;fmt&amp;quot; func main() { var x, y = 13, 3.</description></item><item><title>Golang实现Google-Authenticator</title><link>/post/golang/golang%E5%AE%9E%E7%8E%B0google-authenticator/</link><pubDate>Wed, 05 Aug 2020 20:43:46 +0800</pubDate><guid>/post/golang/golang%E5%AE%9E%E7%8E%B0google-authenticator/</guid><description>什么是Google-Authenticator Google身份验证器是一款基于时间与哈希的一次性密码算法的两步验证软件令牌。也就是我们署成的TOTP（Time-based One-time Password）
通俗的说就是：密钥+算法=code
通过控制变量法，这里我们只需要手机上也设置一样的密钥使用一样的算法，就可以生成一样的code，从而达到二次验证。
使用Go实现生成密码算法 /** * @Author: myxy99 &amp;lt;myxy99@foxmail.</description></item><item><title>Golang-MongoDb方法封装</title><link>/post/golang/golang-mongodb%E6%96%B9%E6%B3%95%E5%B0%81%E8%A3%85/</link><pubDate>Thu, 30 Jul 2020 14:09:50 +0800</pubDate><guid>/post/golang/golang-mongodb%E6%96%B9%E6%B3%95%E5%B0%81%E8%A3%85/</guid><description>Golang操作MongoDb 安装依赖 go get -u github.com/globalsign/mgo MongoDb的方法封装 /** * @Author: myxy99 &amp;lt;myxy99@foxmail.</description></item><item><title>go-micro开发微服务聊天室</title><link>/post/golang/go-micro%E5%BC%80%E5%8F%91%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%81%8A%E5%A4%A9%E5%AE%A4/</link><pubDate>Fri, 24 Jul 2020 14:06:27 +0800</pubDate><guid>/post/golang/go-micro%E5%BC%80%E5%8F%91%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%81%8A%E5%A4%A9%E5%AE%A4/</guid><description>基于go-micro开发的微服务聊天室 技术栈 微服务框架：go-micro
web框架：gin
orm:gorm</description></item><item><title>Golang-mod</title><link>/post/golang/golang-mod/</link><pubDate>Tue, 21 Jul 2020 11:13:36 +0800</pubDate><guid>/post/golang/golang-mod/</guid><description>Golang-mod go modules 是相关Go包的集合。modules是源代码交换和版本控制的单元。 go命令直接支持使用modules，包括记录和解析对其他模块的依赖性。modules替换旧的基于GOPATH的方法来指定在给定构建中使用哪些源文件。(go官方的解释)
使用Mod 开启go mod go env -w GO111MODULE=on // 开启go mod go mod有以下命令： 命令 说明 download download modules to local cache(下载依赖包) edit edit go.</description></item><item><title>Golang与Apollo配置中心</title><link>/post/golang/golang%E4%B8%8Eapollo%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/</link><pubDate>Sat, 18 Jul 2020 07:53:14 +0800</pubDate><guid>/post/golang/golang%E4%B8%8Eapollo%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/</guid><description>Apollo - A reliable configuration management system Apollo（阿波罗）是携程框架部门研发的分布式配置中心，能够集中化管理应用不同环境、不同集群的配置，配置修改后能够实时推送到应用端，并且具备规范的权限、流程治理等特性，适用于微服务配置管理场景。
服务端基于Spring Boot和Spring Cloud开发，打包后可以直接运行，不需要额外安装Tomcat等应用容器。</description></item><item><title>Golang使用WebSocket</title><link>/post/golang/golang%E4%BD%BF%E7%94%A8websocket/</link><pubDate>Fri, 17 Jul 2020 11:19:32 +0800</pubDate><guid>/post/golang/golang%E4%BD%BF%E7%94%A8websocket/</guid><description>Golang使用WebSocket WebSocket是一种通信协议，旨在改善HTTP作为无状态协议通信的效率问题，WebSocket是客户端与服务器之间的全双工连接，客户端和服务器只需要建立一次连接就可以使用该连接进行通信。在我们的项目中，一般客户端是前端页面，使用JavaScript创建WebSocket与后端的WebSocket服务端进行通信。
安装依赖 go get -u github.com/gorilla/websocket
封装方法 package websocketConn import ( &amp;quot;errors&amp;quot; &amp;quot;github.</description></item><item><title>Golang实现将Hexo博客文章推送到微信公众号</title><link>/post/golang/golang%E5%AE%9E%E7%8E%B0%E5%B0%86hexo%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0%E6%8E%A8%E9%80%81%E5%88%B0%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7/</link><pubDate>Wed, 15 Jul 2020 10:53:59 +0800</pubDate><guid>/post/golang/golang%E5%AE%9E%E7%8E%B0%E5%B0%86hexo%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0%E6%8E%A8%E9%80%81%E5%88%B0%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7/</guid><description>Golang实现将Hexo博客文章推送到微信公众号 最近在写博客的时候，就在想，能不能实现博客更新了然后就自动给别人提醒呢？比如每天提醒更新了什么博客。然后就有了这个项目，我的想法就是通过golang进行爬虫，把所有的文章都存储起来，获取到新的文章，然后把新的文章连接进行整合，发送到微信公众号，这样所有的关注了微信公众号的，就能收到，每天更新的新的博客。
实现爬虫 这里我选择的是colly爬虫框架。然后把爬取的数据进行数据库存储。
package main import ( &amp;quot;fmt&amp;quot; &amp;quot;github.com/gocolly/colly&amp;quot; &amp;quot;regexp&amp;quot; &amp;quot;strings&amp;quot; &amp;quot;wx-blog/config&amp;quot; Redis &amp;quot;wx-blog/redis&amp;quot; &amp;quot;wx-blog/utils&amp;quot; ) func main() { i := config.</description></item><item><title>Golang遇上NSQ消息队列</title><link>/post/golang/golang%E9%81%87%E4%B8%8Ansq%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</link><pubDate>Tue, 14 Jul 2020 22:00:38 +0800</pubDate><guid>/post/golang/golang%E9%81%87%E4%B8%8Ansq%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</guid><description>简介 NSQ是一个基于Go语言的分布式实时消息平台, 它具有分布式、去中心化的拓扑结构，支持无限水平扩展。无单点故障、故障容错、高可用性以及能够保证消息的可靠传递的特征。另外，NSQ非常容易配置和部署, 且支持众多的消息协议。支持多种客户端，协议简单。
NSQ的几个组件 nsqd：一个负责接收、排队、转发消息到客户端的守护进程 nsqlookupd：管理拓扑信息, 用于收集nsqd上报的topic和channel,并提供最终一致性的发现服务的守护进程 nsqadmin：一套Web用户界面，可实时查看集群的统计数据和执行相应的管理任务 Docker安装 搭建主NSQ服务 获取到自己的服务器ip 我这里就是我服务器的外网ip 39.</description></item><item><title>Gin表单绑定验证器</title><link>/post/golang/gin%E8%A1%A8%E5%8D%95%E7%BB%91%E5%AE%9A%E9%AA%8C%E8%AF%81%E5%99%A8/</link><pubDate>Mon, 13 Jul 2020 08:34:28 +0800</pubDate><guid>/post/golang/gin%E8%A1%A8%E5%8D%95%E7%BB%91%E5%AE%9A%E9%AA%8C%E8%AF%81%E5%99%A8/</guid><description>gin中内置validator的基础使用 type UserLoginParam struct { Name string `form:&amp;quot;name&amp;quot; json:&amp;quot;name&amp;quot; binding:&amp;quot;required,min=2,max=30&amp;quot;` Password string `form:&amp;quot;password&amp;quot; json:&amp;quot;password&amp;quot; binding:&amp;quot;required,min=8,max=40&amp;quot;` } func TestValidator(t *testing.</description></item><item><title>Golang开发分布式电商网站高并发秒杀系统</title><link>/post/golang/golang%E5%BC%80%E5%8F%91%E5%88%86%E5%B8%83%E5%BC%8F%E7%94%B5%E5%95%86%E7%BD%91%E7%AB%99%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F/</link><pubDate>Sat, 11 Jul 2020 10:21:53 +0800</pubDate><guid>/post/golang/golang%E5%BC%80%E5%8F%91%E5%88%86%E5%B8%83%E5%BC%8F%E7%94%B5%E5%95%86%E7%BD%91%E7%AB%99%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F/</guid><description>这个系统的主要目的在于秒杀，所有其他地方都做的很简单。基础功能不多！
技术栈： web框架：gin
消息队列：RabbitMQ
分布式方案：hash环</description></item><item><title>Golang中的ORM-Gorm的关联模型</title><link>/post/golang/golang%E4%B8%AD%E7%9A%84orm-gorm%E7%9A%84%E5%85%B3%E8%81%94%E6%A8%A1%E5%9E%8B/</link><pubDate>Fri, 10 Jul 2020 09:09:28 +0800</pubDate><guid>/post/golang/golang%E4%B8%AD%E7%9A%84orm-gorm%E7%9A%84%E5%85%B3%E8%81%94%E6%A8%A1%E5%9E%8B/</guid><description>Golang中的ORM-Gorm的关联模型 对于gorm的基础CRUD用法，这里就不论述了，这里主要说下关联模型的问题，因为我自己在查看官方文档进行关联模型操作的时候，总是感觉官方的例子很奇怪，用着很不明白。对于gorm的基础CRUD用法，不明白的可以看看官方文档：https://gorm.io/zh_CN/docs/models.html
创建数据库层面的外键： models.MysqlHandler.Model(&amp;amp;models.Order{}).AddForeignKey(&amp;quot;user_id&amp;quot;, &amp;quot;user(id)&amp;quot;, &amp;quot;RESTRICT&amp;quot;, &amp;quot;RESTRICT&amp;quot;) 说说这里的RESTRICT，这里还可以填CASCADE、NO ACTION、RESTRICT、SET NULL。分别的意思是：</description></item><item><title>Golang微服务开发-grpc</title><link>/post/golang/golang%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91-grpc/</link><pubDate>Fri, 10 Jul 2020 08:12:21 +0800</pubDate><guid>/post/golang/golang%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91-grpc/</guid><description>什么是grpc grpc官网：https://www.grpc.io/
A high-performance, open-source universal RPC framework
这个是官方对他的解释。这里就出现了一个新的名称RPC。什么是RPC呢?</description></item><item><title>Golang实现一致性Hash算法</title><link>/post/golang/golang%E5%AE%9E%E7%8E%B0%E4%B8%80%E8%87%B4%E6%80%A7hash%E7%AE%97%E6%B3%95/</link><pubDate>Thu, 09 Jul 2020 19:49:48 +0800</pubDate><guid>/post/golang/golang%E5%AE%9E%E7%8E%B0%E4%B8%80%E8%87%B4%E6%80%A7hash%E7%AE%97%E6%B3%95/</guid><description>什么是一致性Hash算法 一致性Hash算法是使用取模的方法，一致性Hash算法是对2^32取模，什么意思呢？简单来说，一致性Hash算法将整个哈希值空间组织成一个虚拟的圆环，如假设某哈希函数H的值空间为0-2^32-1（即哈希值是一个32位无符号整形），整个哈希环如下：
圆环的正上方的点代表0，0点右侧的第一个点代表1，以此类推，2、3、4、5、6……直到2^32-1,也就是说0点左侧的第一个点代表2^32-1
我们把这个由2的32次方个点组成的圆环称为hash环。
假设我们有3台缓存服务器，服务器A、服务器B、服务器C，那么，在生产环境中，这三台服务器肯定有自己的IP地址，我们使用它们各自的IP地址进行哈希计算，使用哈希后的结果对2^32取模，可以使用如下公式示意
hash(服务器A的IP地址) % 2^32
通过上述公式算出的结果一定是一个0到2^32-1之间的一个整数，我们就用算出的这个整数，代表服务器A，既然这个整数肯定处于0到2^32-1之间，那么，上图中的hash环上必定有一个点与这个整数对应，而我们刚才已经说明，使用这个整数代表服务器A，那么，服务器A就可以映射到这个环上，用下图示意</description></item><item><title>Golang使用jwt</title><link>/post/golang/golang%E4%BD%BF%E7%94%A8jwt/</link><pubDate>Tue, 07 Jul 2020 20:35:19 +0800</pubDate><guid>/post/golang/golang%E4%BD%BF%E7%94%A8jwt/</guid><description>Golang中使用JWT(json web token) 什么是jwt 什么是jwt这里就不多说了，官网有介绍。官网介绍：https://jwt.io/introduction/
使用步骤 下载依赖包 go get -u github.</description></item><item><title>Protoc-go修改生成的文件的结构体的tag</title><link>/post/golang/protoc-go%E4%BF%AE%E6%94%B9%E7%94%9F%E6%88%90%E7%9A%84%E6%96%87%E4%BB%B6%E7%9A%84%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84tag/</link><pubDate>Tue, 07 Jul 2020 09:22:38 +0800</pubDate><guid>/post/golang/protoc-go%E4%BF%AE%E6%94%B9%E7%94%9F%E6%88%90%E7%9A%84%E6%96%87%E4%BB%B6%E7%9A%84%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84tag/</guid><description>使用场景 在使用protoc生成的文件中生成的结构体的json没有小写，有时候我们就需要使用小写，最主要的就是在使用gin的时候还需要使用bind来绑定上传的东西。但是生成的*.pd.go又不建议我们去改。这时候就需要使用protoc-go-inject-tag，这里还有个更重要的地方，这里简单描述下：生成的结构体中的tag里面有个omitempty，这个的作用呢，就是在数据传输过程中，自动去掉false 0 &amp;quot;&amp;quot;这些数据。这里简单的举个例子，比如你的grpc服务端返回给客户端一个值为false的bool类型数据。但是在客户端接受的时候，这个字段就直接没有了。所以这样肯定是不行的。所以这里需要集体的去掉tag中的omitempty。这个时候protoc-go-inject-tag就可以满足这个需求。在之后的微服务（go-micro）开发中，这个也是很重要的地方！
git地址：https://github.com/favadi/protoc-go-inject-tag
安装 go get github.com/favadi/protoc-go-inject-tag 使用 只需要在.</description></item><item><title>Golang实现依赖注入+gin</title><link>/post/golang/golang%E5%AE%9E%E7%8E%B0%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5+gin/</link><pubDate>Sun, 05 Jul 2020 10:06:47 +0800</pubDate><guid>/post/golang/golang%E5%AE%9E%E7%8E%B0%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5+gin/</guid><description>Go实现依赖注入 最近在使用go开发的时候，发现构建系统依赖树非常繁琐，需要手动去new很多对象，又手工代码将它们拼接起来，写了一堆非常冗繁的代码。之前在laravel的使用中有其强大的ioc，都没有这方面的困扰。就在想golang中有没有好用的依赖注入方案，查询资料，发现了facebook团队开源的inject。GitHub地址：http://github.com/facebookgo/inject
没有依赖注入的系统： 在代码上的表现：
func NewUserRepository() UserRepositoryImp { return &amp;amp;UserManagerRepository{ Db: models.</description></item><item><title>Golang实现RabbitMQ五种模式</title><link>/post/golang/golang%E5%AE%9E%E7%8E%B0rabbitmq%E4%BA%94%E7%A7%8D%E6%A8%A1%E5%BC%8F/</link><pubDate>Fri, 03 Jul 2020 09:16:26 +0800</pubDate><guid>/post/golang/golang%E5%AE%9E%E7%8E%B0rabbitmq%E4%BA%94%E7%A7%8D%E6%A8%A1%E5%BC%8F/</guid><description>使用的依赖包 github.com/streadway/amqp 创建RabbitMQ实例 package RabbitMQ import ( &amp;quot;fmt&amp;quot; &amp;quot;github.com/streadway/amqp&amp;quot; &amp;quot;log&amp;quot; ) // 用户名 密码 ip:端口/虚拟机 const MQURL = &amp;quot;amqp://admin:123456@127.</description></item><item><title>Golang-Redis简易封装</title><link>/post/golang/golang-redis%E7%AE%80%E6%98%93%E5%B0%81%E8%A3%85/</link><pubDate>Wed, 01 Jul 2020 21:12:47 +0800</pubDate><guid>/post/golang/golang-redis%E7%AE%80%E6%98%93%E5%B0%81%E8%A3%85/</guid><description>Golang Redis 下载依赖包 go get github.com/gomodule/redigo Redis 操作封装 配置文件 [redis] Host = 127.</description></item><item><title>Golang邮件发送</title><link>/post/golang/golang%E9%82%AE%E4%BB%B6%E5%8F%91%E9%80%81/</link><pubDate>Sat, 27 Jun 2020 19:27:48 +0800</pubDate><guid>/post/golang/golang%E9%82%AE%E4%BB%B6%E5%8F%91%E9%80%81/</guid><description>golang发送邮件 安装库 go get github.com/jordan-wright/email 简单代码实现 package main import ( &amp;quot;log&amp;quot; &amp;quot;net/smtp&amp;quot; &amp;quot;github.</description></item><item><title>Golang实现雪花算法</title><link>/post/golang/golang%E5%AE%9E%E7%8E%B0%E9%9B%AA%E8%8A%B1%E7%AE%97%E6%B3%95/</link><pubDate>Tue, 16 Jun 2020 13:09:56 +0800</pubDate><guid>/post/golang/golang%E5%AE%9E%E7%8E%B0%E9%9B%AA%E8%8A%B1%E7%AE%97%E6%B3%95/</guid><description>雪花算法 雪花算法 雪花算法的原始版本是scala版，用于生成分布式ID（纯数字，时间顺序）,订单编号等 自增ID：对于数据敏感场景不宜使用，且不适合于分布式场景。 GUID：采用无意义字符串，数据量增大时造成访问过慢，且不宜排序。
算法描述 最高位是符号位，始终为0，不可用。 41位的时间序列，精确到毫秒级，41位的长度可以使用69年。时间位还有一个很重要的作用是可以根据时间进行排序。 10位的机器标识，10位的长度最多支持部署1024个节点。 12位的计数序列号，序列号即一系列的自增id，可以支持同一节点同一毫秒生成多个ID序号，12位的计数序列号支持每个节点每毫秒产生4096个ID序号。 Golang 实现 package main import ( &amp;quot;errors&amp;quot; &amp;quot;fmt&amp;quot; &amp;quot;sync&amp;quot; &amp;quot;time&amp;quot; ) const ( workerBits uint8 = 10 numberBits uint8 = 12 workerMax int64 = -1 ^ (-1 &amp;lt;&amp;lt; workerBits) numberMax int64 = -1 ^ (-1 &amp;lt;&amp;lt; numberBits) timeShift uint8 = workerBits + numberBits workerShift uint8 = numberBits startTime int64 = 1525705533000 // 如果在程序跑了一段时间修改了epoch这个值 可能会导致生成相同的ID ) type Worker struct { mu sync.</description></item><item><title>Golang-HTTP-Server</title><link>/post/golang/golang-http-server/</link><pubDate>Mon, 01 Jun 2020 16:49:56 +0800</pubDate><guid>/post/golang/golang-http-server/</guid><description>GO HTTP Server 使用标准库构建 HTTP 服务 Go 语言标准库自带一个完善的 net/http 包，可以很方便编写一个可以直接运行的 Web 服务。</description></item></channel></rss>